import os
import logging
from google import genai
from google.genai import types
from telegram import Update
from telegram.ext import ApplicationBuilder, MessageHandler, CommandHandler, filters, CallbackContext

# Configuration du bot Telegram
TOKEN = "7708331542:AAEkSO_E9c6WRZnK0BxO49UXLWOonLD85pM"
GEMINI_API_KEY = "AIzaSyCvvmosqHfcb08skdw___PlnFhUid7-ErQ"  # Remplace par ta vraie clé API

# Initialisation du client Gemini
genai_client = genai.Client(api_key=GEMINI_API_KEY)

# Dictionnaire pour stocker l'historique des conversations des utilisateurs
user_histories = {}

# Fonction pour générer une réponse avec Gemini en gardant la mémoire
def generate_response(user_id, user_input):
    model = "gemini-2.0-flash"

    # Récupération de l'historique de l'utilisateur
    if user_id not in user_histories:
        user_histories[user_id] = []

    history = user_histories[user_id]

    # Ajouter le message de l'utilisateur à l'historique
    history.append(types.Content(role="user", parts=[types.Part.from_text(user_input)]))

    # Configuration de la génération de réponse
    generate_config = types.GenerateContentConfig(
        temperature=1,
        top_p=0.95,
        top_k=40,
        max_output_tokens=8192,
        response_mime_type="text/plain",
    )

    # Génération de la réponse par Gemini
    try:
        response = genai_client.models.generate_content(
            model=model,
            contents=history,
            config=generate_config
        )

        # Récupérer la réponse et l'ajouter à l'historique
        response_text = response.candidates[0].content.parts[0].text
        history.append(types.Content(role="model", parts=[types.Part.from_text(response_text)]))

        # Limiter l'historique à 20 messages pour éviter une surcharge
        if len(history) > 20:
            history.pop(0)

        return response_text
    except Exception as e:
        return f"Erreur lors de la génération de la réponse : {str(e)}"

# Fonction pour gérer les messages des utilisateurs
async def handle_message(update: Update, context: CallbackContext):
    user_id = update.message.chat_id
    user_input = update.message.text

    response = generate_response(user_id, user_input)

    await update.message.reply_text(response)

# Fonction pour démarrer le bot
async def start(update: Update, context: CallbackContext):
    await update.message.reply_text("Salut ! Je suis un bot avec une mémoire. Parle-moi et je me souviendrai de nos conversations !")

# Initialisation de l'application Telegram
def main():
    app = ApplicationBuilder().token(TOKEN).build()

    # Commande /start
    app.add_handler(CommandHandler("start", start))

    # Gérer tous les messages
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_message))

    # Lancer le bot
    print("Bot en cours d'exécution...")
    app.run_polling()

if __name__ == "__main__":
    main()

import os
import logging
import google.generativeai as genai
from telegram import Update
from telegram.ext import ApplicationBuilder, MessageHandler, filters, CommandHandler, ContextTypes
import requests
import tempfile

# Configuration du bot Telegram
TELEGRAM_BOT_TOKEN = "7708331542:AAEkSO_E9c6WRZnK0BxO49UXLWOonLD85pM"
GEMINI_API_KEY = "AIzaSyCvvmosqHfcb08skdw___PlnFhUid7-ErQ"

# Configuration de l'API Gemini
genai.configure(api_key=GEMINI_API_KEY)

generation_config = {
    "temperature": 1,
    "top_p": 0.95,
    "top_k": 40,
    "max_output_tokens": 8192,
    "response_mime_type": "text/plain",
}

model = genai.GenerativeModel(
    model_name="gemini-2.0-flash-exp",
    generation_config=generation_config,
)

# Dictionnaire pour stocker l'historique des conversations par utilisateur
user_sessions = {}

# Fonction pour gérer les messages texte
async def handle_text(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.message.from_user.id
    user_message = update.message.text

    if user_id not in user_sessions:
        user_sessions[user_id] = model.start_chat(history=[
            {"role": "user", "parts": ["Hi"]},
            {"role": "model", "parts": ["Hi there! How can I help you today?"]},
        ])

    chat_session = user_sessions[user_id]
    response = chat_session.send_message(user_message)

    await update.message.reply_text(response.text)

# Fonction pour gérer les images
async def handle_photo(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.message.from_user.id
    photo_file = await update.message.photo[-1].get_file()  # Obtenir la meilleure qualité
    photo_url = photo_file.file_path

    # Télécharger l'image temporairement
    with tempfile.NamedTemporaryFile(delete=False, suffix=".jpg") as temp_image:
        response = requests.get(photo_url)
        temp_image.write(response.content)
        temp_image_path = temp_image.name

    # Envoyer l'image à Gemini pour analyse
    chat_session = model.start_chat()
    gemini_response = chat_session.send_message(["Analyze this image:", temp_image_path])

    await update.message.reply_text(f"Gemini Analysis:\n{gemini_response.text}")

    # Supprimer l'image après l'analyse
    os.remove(temp_image_path)

# Fonction pour gérer les messages vocaux (audio)
async def handle_audio(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.message.from_user.id
    audio_file = await update.message.voice.get_file()
    audio_url = audio_file.file_path

    # Télécharger l'audio temporairement
    with tempfile.NamedTemporaryFile(delete=False, suffix=".ogg") as temp_audio:
        response = requests.get(audio_url)
        temp_audio.write(response.content)
        temp_audio_path = temp_audio.name

    # Simuler une réponse (Gemini ne supporte pas l'audio pour le moment)
    response_text = "I received your audio! Currently, I can't process voice messages, but I'm working on it!"
    
    await update.message.reply_text(response_text)

    # Supprimer l'audio après traitement
    os.remove(temp_audio_path)

# Fonction pour la commande /start
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text("Hello! Send me a text, image, or audio, and I'll try to respond.")

# Configuration du bot Telegram
def main():
    logging.basicConfig(level=logging.INFO)
    app = ApplicationBuilder().token(TELEGRAM_BOT_TOKEN).build()

    app.add_handler(CommandHandler("start", start))
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_text))
    app.add_handler(MessageHandler(filters.PHOTO, handle_photo))
    app.add_handler(MessageHandler(filters.VOICE, handle_audio))

    print("Bot is running...")
    app.run_polling()

if __name__ == "__main__":
    main()
